diff --git a/dom/network/interfaces/Makefile.in b/dom/network/interfaces/Makefile.in
index 78ea504..6b490a0 100644
--- a/dom/network/interfaces/Makefile.in
+++ b/dom/network/interfaces/Makefile.in
@@ -15,16 +15,18 @@ include $(topsrcdir)/dom/dom-config.mk
 
 XPIDLSRCS = \
   nsIDOMNavigatorNetwork.idl \
   nsIDOMConnection.idl \
   nsIDOMUSSDReceivedEvent.idl \
   nsIDOMTCPSocket.idl \
   nsITCPSocketParent.idl \
   nsITCPSocketChild.idl \
+  nsITCPServerSocketParent.idl \
+  nsITCPServerSocketChild.idl \
   nsIDOMDataErrorEvent.idl \
   $(NULL)
 
 ifdef MOZ_B2G_RIL
 XPIDLSRCS += \
   nsIDOMMobileConnection.idl \
   nsIMobileConnectionProvider.idl \
   nsINavigatorMobileConnection.idl \
diff --git a/dom/network/interfaces/nsIDOMTCPSocket.idl b/dom/network/interfaces/nsIDOMTCPSocket.idl
index 1e9e03a..c25ff3a 100644
--- a/dom/network/interfaces/nsIDOMTCPSocket.idl
+++ b/dom/network/interfaces/nsIDOMTCPSocket.idl
@@ -1,35 +1,66 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
- * MozTCPSocket exposes a TCP client socket (no server sockets yet)
+ * MozTCPSocket exposes a TCP client and server sockets
  * to highly privileged apps. It provides a buffered, non-blocking
  * interface for sending. For receiving, it uses an asynchronous,
  * event handler based interface.
  */
 
 #include "domstubs.idl"
 #include "nsIDOMEvent.idl"
+#include "nsIServerSocket.idl"
 
 // Bug 731746 - Allow chrome JS object to implement nsIDOMEventTarget
 // nsITCPSocket should be an nsIEventTarget but js objects
 // cannot be an nsIEventTarget yet
 // #include "nsIEventTarget.idl"
 
 // Bug 723206 - Constructors implemented in JS from IDL should be
 //              allowed to have arguments
 //
 //  Once bug 723206 will be fixed, this method could be replaced by
 //  arguments when instantiating a TCPSocket object. For example it will
 //  be possible to do (similarly to the WebSocket API):
 //    var s = new MozTCPSocket(host, port); 
 
+// Bug 797561 - Expose a server tcp socket API to web applications
+
+
+/**
+ * nsIDOMTCPServerSocket
+ *
+ * An interface to a server socket that can accept incoming connections for gaia apps.
+ */
+[scriptable, uuid(821638a1-5327-416d-8031-668764f2ec04)]
+interface nsIDOMTCPServerSocket : nsIServerSocket
+{
+  /**
+   * The port of this server socket object.
+   */
+  readonly attribute unsigned short port;
+
+  /**
+   * The onaccept event handler is called when a client connection is accepted.
+   * The data attribute of the event passed to the onaccept handler will be a TCPSocket
+   * instance, which is used for communication between client and server. 
+   */
+  attribute jsval onaccept;
+
+  /**
+   * Close the server socket.
+   */
+  void close();
+};
+
+
 [scriptable, uuid(b82e17da-6476-11e1-8813-57a2ffe9e42c)]
 interface nsIDOMTCPSocket : nsISupports
 {
   /**
    * Create and return a socket object which will attempt to connect to
    * the given host and port.
    *
    * @param host The hostname of the server to connect to.
@@ -74,16 +105,35 @@ interface nsIDOMTCPSocket : nsISupports
    */
   void suspend();
 
   /**
    * Resume reading incoming data and invoking ondata as usual.
    */
   void resume();
 
+  /** 
+   * Listen a port
+   *
+   * @param port The port of the server socket. Pass -1 to indicate no preference,
+   *        and a port will be selected automatically.
+   * @param options An object specifying one or more parameters which
+   *                determine the details of the socket.
+   *
+   *        binaryType: "arraybuffer" to use UInt8 array
+   *          instances in the ondata callback and as the argument
+   *          to send. Defaults to "string", to use JavaScript strings.
+   * @param backlog The maximum length the queue of pending connections may grow to.
+   *                This parameter may be silently limited by the operating system.
+   *                Pass -1 to use the default value.
+   *
+   * @return The new TCPServerSocket instance.
+   */
+  nsIDOMTCPServerSocket listen(in unsigned short port, [optional] in jsval options, [optional] in unsigned short backlog);
+
   /**
    * Close the socket.
    */
   void close();
 
   /**
    * Write data to the socket.
    *
@@ -193,16 +243,25 @@ interface nsITCPSocketInternal : nsISupports {
 
   // Trigger the callback for |type| with no argument
   void callListenerVoid(in DOMString type);
 
   // Update the DOM object's readyState and bufferedAmount values with the provided data
   void updateReadyStateAndBuffered(in DOMString readyState, in uint32_t bufferedAmount);
 };
 
+/*
+ * Internal interfaces for use in cross-process server-socket implementation.
+*/
+[scriptable, uuid(b64b1e68-4efa-497c-b0d8-69f067ad5ec8)]
+interface nsITCPServerSocketInternal : nsISupports {
+  // Listener for detecting accepted socket in chrome prcocess.
+  void callListenerAccept(in uint16_t port, in uint16_t socketID);
+};
+
 /**
  * nsITCPSocketEvent is the event object which is passed as the
  * first argument to all the event handler callbacks. It contains
  * the socket that was associated with the event, the type of event,
  * and the data associated with the event (if any).
  */
 
 [scriptable, uuid(0f2abcca-b483-4539-a3e8-345707f75c44)]
diff --git a/dom/network/interfaces/nsITCPServerSocketChild.idl b/dom/network/interfaces/nsITCPServerSocketChild.idl
new file mode 100644
index 0000000..ed76619
--- /dev/null
+++ b/dom/network/interfaces/nsITCPServerSocketChild.idl
@@ -0,0 +1,20 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "domstubs.idl"
+
+interface nsITCPServerSocketInternal;
+
+// Interface to allow the content process socket to reach the IPC bridge.
+[scriptable, uuid(41a77ec8-fd86-409e-aea9-af2ca407ef8e)]
+interface nsITCPServerSocketChild : nsISupports
+{
+  // Tell the chrome process to open a corresponding connection with the given parameters
+  [implicit_jscontext]
+  void listen(in nsITCPServerSocketInternal serverSocket, in unsigned short port,
+              in unsigned short backlog, in DOMString binaryType);
+
+  // Tell the chrome process to perform equivalent operations to all following methods
+  void close();
+};
diff --git a/dom/network/interfaces/nsITCPServerSocketParent.idl b/dom/network/interfaces/nsITCPServerSocketParent.idl
new file mode 100644
index 0000000..d17e974
--- /dev/null
+++ b/dom/network/interfaces/nsITCPServerSocketParent.idl
@@ -0,0 +1,20 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "domstubs.idl"
+
+interface nsIDOMTCPServerSocket;
+
+// Interface required to allow the TCP server-socket object in the parent process
+// to talk to the parent IPC actor
+[scriptable, uuid(161ffc9f-54d3-4f21-a536-4166003d0e1d)]
+interface nsITCPServerSocketParent : nsISupports
+{
+  // Trigger a callback in the content process for |type|, providing a serialized
+  // argument of |data|, and update the child's readyState and bufferedAmount values
+  // with the given values.
+  [implicit_jscontext] void sendCallbackAccept(in uint16_t port,
+                                               in uint16_t socketID);
+};
+
diff --git a/dom/network/interfaces/nsITCPSocketParent.idl b/dom/network/interfaces/nsITCPSocketParent.idl
index 346e11a..c4b5d41 100644
--- a/dom/network/interfaces/nsITCPSocketParent.idl
+++ b/dom/network/interfaces/nsITCPSocketParent.idl
@@ -1,15 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "domstubs.idl"
 
 interface nsIDOMTCPSocket;
+interface nsIDOMTCPServerSocket;
+interface nsITCPServerSocketParent;
 
 // Interface required to allow the TCP socket object in the parent process
 // to talk to the parent IPC actor
 [scriptable, uuid(4e7246c6-a8b3-426d-9c17-76dab1e1e14a)]
 interface nsITCPSocketParent : nsISupports
 {
   [implicit_jscontext] void initJS(in jsval intermediary);
 
@@ -26,14 +28,22 @@ interface nsITCPSocketParent : nsISupports
 // and kicking off the chrome process socket object's connection.
 [scriptable, uuid(afa42841-a6cb-4a91-912f-93099f6a3d18)]
 interface nsITCPSocketIntermediary : nsISupports {
   // Open the connection to the server with the given parameters
   nsIDOMTCPSocket open(in nsITCPSocketParent parent,
                        in DOMString host, in unsigned short port,
                        in boolean useSSL, in DOMString binaryType);
 
+  // Listen on a port
+  nsIDOMTCPServerSocket listen(in nsITCPServerSocketParent parent,
+              in unsigned short port, in unsigned short backlog,
+              in DOMString binaryType);
+
+  // Post-processing in closing a server socket
+  void postProcCloseServer(in unsigned short port);
+
   // Send a basic string along the connection
   void sendString(in DOMString data);
 
   // Send a typed array
   void sendArrayBuffer(in jsval data);
 };
diff --git a/dom/network/src/Makefile.in b/dom/network/src/Makefile.in
index 0bb3693..dda3477 100644
--- a/dom/network/src/Makefile.in
+++ b/dom/network/src/Makefile.in
@@ -37,25 +37,29 @@ include $(topsrcdir)/dom/dom-config.mk
 EXPORTS_NAMESPACES = mozilla/dom/network
 
 EXPORTS_mozilla/dom/network = \
   Utils.h \
   Types.h \
   Constants.h \
   TCPSocketChild.h \
   TCPSocketParent.h \
+  TCPServerSocketChild.h \
+  TCPServerSocketParent.h \
   $(NULL)
 
 CPPSRCS = \
   Connection.cpp \
   Utils.cpp \
   USSDReceivedEvent.cpp \
   DataErrorEvent.cpp \
   TCPSocketParent.cpp \
   TCPSocketChild.cpp \
+  TCPServerSocketParent.cpp \
+  TCPServerSocketChild.cpp \
   $(NULL)
 
 ifdef MOZ_B2G_RIL
 CPPSRCS += \
   MobileConnection.cpp \
   $(NULL)
 endif
 
diff --git a/dom/network/src/PTCPServerSocket.ipdl b/dom/network/src/PTCPServerSocket.ipdl
new file mode 100644
index 0000000..e3f0f3d
--- /dev/null
+++ b/dom/network/src/PTCPServerSocket.ipdl
@@ -0,0 +1,34 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 ft=cpp : */
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PNecko;
+
+include "mozilla/net/NeckoMessageUtils.h";
+
+using mozilla::void_t;
+
+namespace mozilla {
+namespace net {
+
+//-------------------------------------------------------------------
+protocol PTCPServerSocket
+{
+  manager PNecko;
+
+parent:
+  Close();
+  RequestDelete();
+
+child:
+  CallbackAccept(uint16_t port, uint16_t socketID);
+  //CallbackError(JSError error);
+  __delete__();
+};
+
+} // namespace net
+} // namespace mozilla
+
diff --git a/dom/network/src/TCPServerSocketChild.cpp b/dom/network/src/TCPServerSocketChild.cpp
new file mode 100644
index 0000000..111488a
--- /dev/null
+++ b/dom/network/src/TCPServerSocketChild.cpp
@@ -0,0 +1,99 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "TCPServerSocketChild.h"
+#include "mozilla/net/NeckoChild.h"
+#include "mozilla/dom/PBrowserChild.h"
+#include "mozilla/dom/TabChild.h"
+#include "nsIDOMTCPSocket.h"
+#include "nsJSUtils.h"
+#include "nsContentUtils.h"
+#include "jsapi.h"
+#include "jsfriendapi.h"
+
+using mozilla::net::gNeckoChild;
+
+namespace mozilla {
+namespace dom {
+
+NS_IMPL_CYCLE_COLLECTION_1(TCPServerSocketChildBase, mServerSocket)
+NS_IMPL_CYCLE_COLLECTING_ADDREF(TCPServerSocketChildBase)
+NS_IMPL_CYCLE_COLLECTING_RELEASE(TCPServerSocketChildBase)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(TCPServerSocketChildBase)
+  NS_INTERFACE_MAP_ENTRY(nsITCPServerSocketChild)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+TCPServerSocketChildBase::TCPServerSocketChildBase()
+: mIPCOpen(false)
+{
+}
+
+TCPServerSocketChildBase::~TCPServerSocketChildBase()
+{
+}
+
+NS_IMETHODIMP_(nsrefcnt) TCPServerSocketChild::Release(void)
+{
+  nsrefcnt refcnt = TCPServerSocketChildBase::Release();
+  if (refcnt == 1 && mIPCOpen) {
+    PTCPServerSocketChild::SendRequestDelete();
+    return 1;
+  }
+  return refcnt;
+}
+
+TCPServerSocketChild::TCPServerSocketChild()
+{
+}
+
+NS_IMETHODIMP
+TCPServerSocketChild::Listen(nsITCPServerSocketInternal* aServerSocket, uint16_t aPort,
+  uint16_t aBacklog, const nsAString & aBinaryType, JSContext* aCx)
+{
+  mServerSocket = aServerSocket;
+  AddIPDLReference();
+  gNeckoChild->SendPTCPServerSocketConstructor(this, aPort, aBacklog, nsString(aBinaryType));
+  return NS_OK;
+}
+
+void
+TCPServerSocketChildBase::ReleaseIPDLReference()
+{
+  MOZ_ASSERT(mIPCOpen);
+  mIPCOpen = false;
+  this->Release();
+}
+
+void
+TCPServerSocketChildBase::AddIPDLReference()
+{
+  MOZ_ASSERT(!mIPCOpen);
+  mIPCOpen = true;
+  this->AddRef();
+}
+
+TCPServerSocketChild::~TCPServerSocketChild()
+{
+}
+
+bool
+TCPServerSocketChild::RecvCallbackAccept(const uint16_t& aPort,
+                             const uint16_t& aSocketID)
+{
+  nsresult rv = mServerSocket->CallListenerAccept(aPort, aSocketID);
+  NS_ENSURE_SUCCESS(rv, true);
+  return true;
+}
+
+NS_IMETHODIMP
+TCPServerSocketChild::Close()
+{
+  SendClose();
+  return NS_OK;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/network/src/TCPServerSocketChild.h b/dom/network/src/TCPServerSocketChild.h
new file mode 100644
index 0000000..6d1841d
--- /dev/null
+++ b/dom/network/src/TCPServerSocketChild.h
@@ -0,0 +1,51 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/net/PTCPServerSocketChild.h"
+#include "nsITCPServerSocketChild.h"
+#include "nsCycleCollectionParticipant.h"
+#include "nsCOMPtr.h"
+
+#define TCPSERVERSOCKETCHILD_CID \
+  { 0x41a77ec8, 0xfd86, 0x409e, { 0xae, 0xa9, 0xaf, 0x2c, 0xa4, 0x07, 0xef, 0x8e } }
+
+class nsITCPServerSocketInternal;
+struct JSContext;
+struct JSObject;
+
+namespace mozilla {
+namespace dom {
+
+class TCPServerSocketChildBase : public nsITCPServerSocketChild {
+public:
+  NS_DECL_CYCLE_COLLECTION_CLASS(TCPServerSocketChildBase)
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+
+  void AddIPDLReference();
+  void ReleaseIPDLReference();
+
+protected:
+  TCPServerSocketChildBase();
+  virtual ~TCPServerSocketChildBase();
+
+  nsCOMPtr<nsITCPServerSocketInternal> mServerSocket;
+  bool mIPCOpen;
+};
+
+class TCPServerSocketChild : public mozilla::net::PTCPServerSocketChild
+                           , public TCPServerSocketChildBase
+{
+public:
+  NS_DECL_NSITCPSERVERSOCKETCHILD
+  NS_IMETHOD_(nsrefcnt) Release() MOZ_OVERRIDE;
+
+  TCPServerSocketChild();
+  ~TCPServerSocketChild();
+
+  virtual bool RecvCallbackAccept(const uint16_t& aPort,
+                                  const uint16_t& aSocketID) MOZ_OVERRIDE;
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/network/src/TCPServerSocketParent.cpp b/dom/network/src/TCPServerSocketParent.cpp
new file mode 100644
index 0000000..2dacf2c
--- /dev/null
+++ b/dom/network/src/TCPServerSocketParent.cpp
@@ -0,0 +1,98 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "TCPServerSocketParent.h"
+#include "jsapi.h"
+#include "jsfriendapi.h"
+#include "nsJSUtils.h"
+#include "nsIDOMTCPSocket.h"
+#include "mozilla/unused.h"
+#include "mozilla/AppProcessPermissions.h"
+
+//Defined in TCPServerSocketChild.cpp
+
+namespace mozilla {
+namespace dom {
+
+static void
+FireInteralError(mozilla::net::PTCPServerSocketParent* aActor, uint32_t aLineNo)
+{
+// todo: error callback
+}
+
+NS_IMPL_CYCLE_COLLECTION_2(TCPServerSocketParent, mServerSocket, mIntermediary)
+NS_IMPL_CYCLE_COLLECTING_ADDREF(TCPServerSocketParent)
+NS_IMPL_CYCLE_COLLECTING_RELEASE(TCPServerSocketParent)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(TCPServerSocketParent)
+  NS_INTERFACE_MAP_ENTRY(nsITCPServerSocketParent)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+bool
+TCPServerSocketParent::Init(const uint16_t& aPort, const uint16_t& aBacklog,
+  const nsString& aBinaryType)
+{
+  nsresult rv;
+  mIntermediary = do_CreateInstance("@mozilla.org/tcp-socket-intermediary;1", &rv);
+  if (NS_FAILED(rv)) {
+    FireInteralError(this, __LINE__);
+    return true;
+  }
+
+  rv = mIntermediary->Listen(this, aPort, aBacklog, aBinaryType, getter_AddRefs(mServerSocket));
+  if (NS_FAILED(rv) || !mServerSocket) {
+    FireInteralError(this, __LINE__);
+    return true;
+  }
+  return true;
+}
+
+NS_IMETHODIMP
+TCPServerSocketParent::SendCallbackAccept(uint16_t port,
+  uint16_t socketID, JSContext* aCx)
+{
+  mozilla::unused <<
+    PTCPServerSocketParent::SendCallbackAccept(port, socketID);
+  return NS_OK;
+}
+
+bool
+TCPServerSocketParent::RecvClose()
+{
+  nsresult rv;
+  uint16_t aPort = 999;
+
+  NS_ENSURE_TRUE(mServerSocket, true);
+  rv = mServerSocket->Close();
+  NS_ENSURE_SUCCESS(rv, true);
+  rv = mServerSocket->GetPort(&aPort);
+  NS_ENSURE_SUCCESS(rv, true);
+  rv = mIntermediary->PostProcCloseServer(aPort);
+  NS_ENSURE_SUCCESS(rv, true);
+  return true;
+}
+
+void
+TCPServerSocketParent::ActorDestroy(ActorDestroyReason why)
+{
+  MOZ_ASSERT(mIPCOpen);
+  mIPCOpen = false;
+  if (mServerSocket) {
+    mServerSocket->Close();
+  }
+  mServerSocket = nullptr;
+  mIntermediaryObj = nullptr;
+  mIntermediary = nullptr;
+}
+
+bool
+TCPServerSocketParent::RecvRequestDelete()
+{
+  mozilla::unused << Send__delete__(this);
+  return true;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/network/src/TCPServerSocketParent.h b/dom/network/src/TCPServerSocketParent.h
new file mode 100644
index 0000000..53fda69
--- /dev/null
+++ b/dom/network/src/TCPServerSocketParent.h
@@ -0,0 +1,45 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/net/PTCPServerSocketParent.h"
+#include "nsITCPSocketParent.h"
+#include "nsITCPServerSocketParent.h"
+#include "nsCycleCollectionParticipant.h"
+#include "nsCOMPtr.h"
+#include "nsIDOMTCPSocket.h"
+
+struct JSContext;
+struct JSObject;
+
+namespace mozilla {
+namespace dom {
+
+class PBrowserParent;
+
+class TCPServerSocketParent : public mozilla::net::PTCPServerSocketParent
+                            , public nsITCPServerSocketParent
+{
+public:
+  NS_DECL_CYCLE_COLLECTION_CLASS(TCPServerSocketParent)
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_NSITCPSERVERSOCKETPARENT
+
+  TCPServerSocketParent() : mIntermediaryObj(nullptr), mIPCOpen(true) {}
+
+  bool Init(const uint16_t& aPort, const uint16_t& aBacklog, const nsString& aBinaryType);
+
+  virtual bool RecvClose() MOZ_OVERRIDE;
+  virtual bool RecvRequestDelete() MOZ_OVERRIDE;
+
+private:
+  virtual void ActorDestroy(ActorDestroyReason why) MOZ_OVERRIDE;
+
+  nsCOMPtr<nsITCPSocketIntermediary> mIntermediary;
+  nsCOMPtr<nsIDOMTCPServerSocket> mServerSocket;
+  JSObject* mIntermediaryObj;
+  bool mIPCOpen;
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/network/src/TCPSocket.js b/dom/network/src/TCPSocket.js
index b19cec9..4dfedd4 100644
--- a/dom/network/src/TCPSocket.js
+++ b/dom/network/src/TCPSocket.js
@@ -19,33 +19,41 @@ const InputStreamPump = CC(
         "@mozilla.org/network/async-stream-copier;1", "nsIAsyncStreamCopier", "init"),
       ScriptableInputStream = CC(
         "@mozilla.org/scriptableinputstream;1", "nsIScriptableInputStream", "init"),
       BinaryInputStream = CC(
         "@mozilla.org/binaryinputstream;1", "nsIBinaryInputStream", "setInputStream"),
       StringInputStream = CC(
         '@mozilla.org/io/string-input-stream;1', 'nsIStringInputStream'),
       MultiplexInputStream = CC(
-        '@mozilla.org/io/multiplex-input-stream;1', 'nsIMultiplexInputStream');
+        '@mozilla.org/io/multiplex-input-stream;1', 'nsIMultiplexInputStream'),
+      ServerSocket = CC(
+        '@mozilla.org/network/server-socket;1', 'nsIServerSocket', 'init');
 
 const kCONNECTING = 'connecting';
 const kOPEN = 'open';
 const kCLOSING = 'closing';
 const kCLOSED = 'closed';
 
 const BUFFER_SIZE = 65536;
 
 /*
  * Debug logging function
  */
 
 let debug = true;
-function LOG(msg) {
-  if (debug)
-    dump("TCPSocket: " + msg + "\n");
+function LOG(msg, host) {
+  if (debug) {
+    if (host) {
+      dump("TCPSocket(" + host + "): " + msg + "\n");
+    }
+    else {
+      dump("TCPSocket: " + msg + "\n");
+    }
+  }
 }
 
 /*
  * nsITCPSocketEvent object
  */
 
 function TCPSocketEvent(type, sock, data) {
   this._type = type;
@@ -66,16 +74,171 @@ TCPSocketEvent.prototype = {
     return this._target;
   },
   get data() {
     return this._data;
   }
 }
 
 /*
+ * nsIDOMTCPServerSocket object
+ */
+
+function TCPServerSocket() {
+  this._listener = null;
+  this._port = 0;
+  this._onaccept = null;
+  this._inChild = false;
+  this._serverBridge = null;
+  this._tcpsocklist = [];
+  this._useWin = null;
+}
+
+TCPServerSocket.prototype = {
+  __exposedProps__: {
+    port: 'r',
+    onaccept: 'rw'
+  },
+  get port() {
+    return this._port;
+  },
+  get onaccept() {
+    return this._onaccept;
+  },
+  set onaccept(f) {
+    this._onaccept=f;
+  },
+
+  _initAcceptedSocket: function tss_initAcceptedSocket(transport, options) {
+    let that = new TCPSocket();
+    
+    if (options !== undefined) {
+      that._binaryType = options.binaryType || that._binaryType;
+    }
+
+    that._socketInputStream = transport.openInputStream(0, 0, 0);
+    that._socketOutputStream = transport.openOutputStream(Ci.nsITransport.OPEN_UNBUFFERED, 0, 0);
+    
+    // If the other side is not listening, we will
+    // get an onInputStreamReady callback where available
+    // raises to indicate the connection was refused.
+    
+    if (that._binaryType === "arraybuffer") {
+      that._inputStreamBinary = new BinaryInputStream(that._socketInputStream);
+    } else {
+      that._inputStreamScriptable = new ScriptableInputStream(that._socketInputStream);
+    }
+
+    that._multiplexStream = new MultiplexInputStream();
+    that._multiplexStreamCopier = new AsyncStreamCopier(
+      that._multiplexStream,
+      that._socketOutputStream,
+      // (nsSocketTransport uses gSocketTransportService)
+      Cc["@mozilla.org/network/socket-transport-service;1"]
+        .getService(Ci.nsIEventTarget),
+      /* source buffered */ true, /* sink buffered */ false,
+      BUFFER_SIZE, /* close source*/ false, /* close sink */ false);
+    /* ReadyState for TCPSocket Object is kOpen since transport stream has already been connected */
+    that._readyState = kOPEN;
+    that._inputStreamPump = new InputStreamPump(that._socketInputStream, -1, -1, 0, 0, false);
+
+    while (that._suspendCount--) {
+      that._inputStreamPump.suspend();
+     }
+
+    that._inputStreamPump.asyncRead(that, null);
+    return that;
+  },
+
+  _listen: function tss_listen(port, backlog, options) {
+    this._port = port;
+    this._options = options;
+    
+    this._listener = new ServerSocket(port, false, backlog);
+    this._listener.asyncListen(this);
+  },
+
+  _callListenerAcceptCommon: function tss_callListenerAcceptCommon(tcpsock) {
+    if (this._onaccept) {
+      this._tcpsocklist.push(tcpsock);
+      this._onaccept(tcpsock);
+    }
+    else {
+      dump("Received unexpected connection!");
+    }
+  },
+  
+  /* nsITCPServerSocketInternal method */
+  callListenerAccept: function tss_callListenerAccept(port, socketID) {
+    // this method is called at child process when the socket is accepted at parent process.
+    let that = new TCPSocket();
+
+    that._inChild = true;
+    that._port = port;
+    that._readyState = kOPEN;
+    that._socketBridge = Cc["@mozilla.org/tcp-socket-child;1"]
+                            .createInstance(Ci.nsITCPSocketChild);
+    that._socketBridge.open(that, "openAccepted:" + socketID, port, false, "",
+                            this._useWin, that);
+    this._callListenerAcceptCommon(that);
+  },
+  /* end nsITCPServerSocketInternal method */
+
+  close: function tss_close() {
+    dump('TCPServerSocket::close() is called(inChild=' + this._inChild + ')');
+
+    if (this._inChild) {
+      this._serverBridge.close();
+      return;
+    }
+
+    /*Close accepted TCPSockets*/
+    for (var i = 0; i < this._tcpsocklist.length; i++) {
+      this._tcpsocklist[i].close();
+    }
+    /*Close ServerSocket*/
+    this._listener.close();
+  },
+
+  // nsIServerSocketListener (Triggered by _listener.asyncListen)
+  onSocketAccepted: function tss_onSocketAccepted(server, trans) {
+    // precondition: this._inChild == false
+    var tcpsock = this._initAcceptedSocket(trans, this._options);
+    this._callListenerAcceptCommon(tcpsock)
+  },
+
+  // nsIServerSocketListener (Triggered by _listener.asyncListen)
+  onStopListening: function tss_onStopListening(server, status) {
+    LOG("onStopListening was called.");
+  },
+
+  classID: Components.ID("{73065eae-27dc-11e2-895a-000c29987aa2}"),
+
+  classInfo: XPCOMUtils.generateCI({
+    classID: Components.ID("{73065eae-27dc-11e2-895a-000c29987aa2}"),
+    classDescription: "Server TCP Socket",
+    interfaces: [
+      Ci.nsIDOMTCPServerSocket,
+      Ci.nsIDOMGlobalPropertyInitializer,
+      Ci.nsIObserver,
+      Ci.nsISupportsWeakReference
+    ],
+    flags: Ci.nsIClassInfo.DOM_OBJECT,
+  }),
+
+  QueryInterface: XPCOMUtils.generateQI([
+    Ci.nsIDOMTCPServerSocket,
+    Ci.nsITCPServerSocketInternal,
+    Ci.nsIDOMGlobalPropertyInitializer,
+    Ci.nsIObserver,
+    Ci.nsISupportsWeakReference
+  ])
+}
+
+/*
  * nsIDOMTCPSocket object
  */
 
 function TCPSocket() {
   this._readyState = kCLOSED;
 
   this._onopen = null;
   this._ondrain = null;
@@ -107,16 +270,17 @@ TCPSocket.prototype = {
     ssl: 'r',
     bufferedAmount: 'r',
     suspend: 'r',
     resume: 'r',
     close: 'r',
     send: 'r',
     readyState: 'r',
     binaryType: 'r',
+    listen: 'r',
     onopen: 'rw',
     ondrain: 'rw',
     ondata: 'rw',
     onerror: 'rw',
     onclose: 'rw'
   },
   // The binary type, "string" or "arraybuffer"
   _binaryType: null,
@@ -412,16 +576,52 @@ TCPSocket.prototype = {
       // (nsSocketTransport uses gSocketTransportService)
       Cc["@mozilla.org/network/socket-transport-service;1"]
         .getService(Ci.nsIEventTarget),
       /* source buffered */ true, /* sink buffered */ false,
       BUFFER_SIZE, /* close source*/ false, /* close sink */ false);
 
     return that;
   },
+  
+  listen: function ts_listen(port, options, backlog) {
+    if (!this.initWindowless())
+      return null;
+
+    this._inChild = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime)
+                       .processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT;
+    LOG("content process: " + (this._inChild ? "true" : "false") + "\n");
+
+    // in the testing case, init won't be called and
+    // hasPrivileges will be null. We want to proceed to test.
+    if (this._hasPrivileges !== true && this._hasPrivileges !== null) {
+      throw new Error("TCPSocket does not have permission in this context.\n");
+    }
+
+    var that = new TCPServerSocket();
+
+    that._useWin = this.useWin;
+    that._inChild = this._inChild;
+    that._onaccept = function() {
+      LOG("Default onaccept handler(set by TCPSocket.listen())");
+    };
+
+    if (that._inChild) {
+      var binaryType = options.binaryType || that._binaryType;
+
+      that._serverBridge = Cc["@mozilla.org/tcp-server-socket-child;1"]
+                             .createInstance(Ci.nsITCPServerSocketChild);
+      that._serverBridge.listen(that, port, backlog || -1, binaryType);
+	}
+    else {
+      that._listen(port, backlog || -1, options);
+    }
+
+    return that;
+  },
 
   close: function ts_close() {
     if (this._readyState === kCLOSED || this._readyState === kCLOSING)
       return;
 
     LOG("close called\n");
     this._readyState = kCLOSING;
 
diff --git a/dom/network/src/TCPSocketParentIntermediary.js b/dom/network/src/TCPSocketParentIntermediary.js
index 1b1712a..017c933 100644
--- a/dom/network/src/TCPSocketParentIntermediary.js
+++ b/dom/network/src/TCPSocketParentIntermediary.js
@@ -2,30 +2,47 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
+var port2AcceptedSocketList = {};
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 function TCPSocketParentIntermediary() {
 }
 
 TCPSocketParentIntermediary.prototype = {
   open: function(aParentSide, aHost, aPort, aUseSSL, aBinaryType) {
     aParentSide.initJS(this);
 
-    let baseSocket = Cc["@mozilla.org/tcp-socket;1"].createInstance(Ci.nsIDOMTCPSocket);
-    let socket = this._socket = baseSocket.open(aHost, aPort,
-                                                {useSSL: aUseSSL,
-                                                binaryType: aBinaryType});
+    let socket = null;
+
+    // If aHost is set as 'openAccepted:xxx' instead of host name (e.g. localhost), 
+    // an accepted socket object created by listen()is returned
+    //('xxx' is an index of socket list).
+    if (0 != aHost.indexOf('openAccepted')) {
+      let baseSocket = Cc["@mozilla.org/tcp-socket;1"].createInstance(Ci.nsIDOMTCPSocket);
+
+      socket = this._socket = baseSocket.open(aHost, aPort,
+                                              {useSSL: aUseSSL,
+                                              binaryType: aBinaryType});
+    }
+    else {
+      var socketID = new Number(aHost.split(':')[1]);
+
+      socket = this._socket = port2AcceptedSocketList[aPort][socketID];
+    }
+
+    this._host = aHost;
+
     if (!socket)
       return null;
 
     // Create handlers for every possible callback that attempt to trigger
     // corresponding callbacks on the child object.
     ["open", "drain", "data", "error", "close"].forEach(
       function(p) {
         socket["on" + p] = function(data) {
@@ -33,16 +50,42 @@ TCPSocketParentIntermediary.prototype = {
                                    socket.bufferedAmount);
         };
       }
     );
 
     return socket;
   },
 
+  listen: function(aTCPServerSocket, aPort, aBacklog, aBinaryType) {
+    let baseSocket = Cc["@mozilla.org/tcp-socket;1"].createInstance(Ci.nsIDOMTCPSocket);
+    let serverSocket = baseSocket.listen(aPort, { binaryType: aBinaryType }, aBacklog);
+
+    if (!serverSocket)
+      return null;
+
+    serverSocket["onaccept"] = function(tcpSocket) {
+      if (port2AcceptedSocketList[aPort] === undefined) {
+        port2AcceptedSocketList[aPort] = [];
+      }
+
+      port2AcceptedSocketList[aPort].push(tcpSocket);
+
+      var socketID = port2AcceptedSocketList[aPort].length - 1;
+      aTCPServerSocket.sendCallbackAccept(aPort, socketID);
+    }
+
+    return serverSocket;
+  },
+
+  postProcCloseServer: function(aPort) {
+    dump('TCPSocketParentIntermediary.postProcCloseServer() is called(aPort=' + aPort + ').');
+    delete port2AcceptedSocketList[aPort];
+  },
+
   sendString: function(aData) {
     return this._socket.send(aData);
   },
 
   sendArrayBuffer: function(aData) {
     return this._socket.send(aData);
   },
 
diff --git a/dom/network/src/ipdl.mk b/dom/network/src/ipdl.mk
index 6efad31..0a463d7 100644
--- a/dom/network/src/ipdl.mk
+++ b/dom/network/src/ipdl.mk
@@ -1,7 +1,8 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 IPDLSRCS = \
   PTCPSocket.ipdl \
+  PTCPServerSocket.ipdl \
   $(NULL)
diff --git a/dom/network/tests/unit/test_tcpserversocket.js b/dom/network/tests/unit/test_tcpserversocket.js
new file mode 100644
index 0000000..2377c54
--- /dev/null
+++ b/dom/network/tests/unit/test_tcpserversocket.js
@@ -0,0 +1,557 @@
+/**
+ * Test TCPSocket.js by creating an XPCOM-style server socket, then sending
+ * data in both directions and making sure each side receives their data
+ * correctly and with the proper events.
+ *
+ * This test is derived from netwerk/test/unit/test_socks.js, except we don't
+ * involve a subprocess.
+ *
+ * Future work:
+ * - SSL.  see https://bugzilla.mozilla.org/show_bug.cgi?id=466524
+ *             https://bugzilla.mozilla.org/show_bug.cgi?id=662180
+ *   Alternatively, mochitests could be used.
+ * - Testing overflow logic.
+ *
+ **/
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+const Cu = Components.utils;
+const CC = Components.Constructor;
+
+/**
+ *
+ * Constants
+ *
+ */
+
+// Test parameter.
+const PORT = 10010;
+const BACKLOG = -1;
+
+// Some binary data to send.
+const DATA_ARRAY = [0, 255, 254, 0, 1, 2, 3, 0, 255, 255, 254, 0],
+      DATA_ARRAY_2 = [0, 254, 255, 255, 0, 3, 2, 1, 0, 254, 255, 0],
+      TYPED_DATA_ARRAY = new Uint8Array(DATA_ARRAY),
+      TYPED_DATA_ARRAY_2 = new Uint8Array(DATA_ARRAY_2),
+      HELLO_WORLD = "hlo wrld. ",
+      BIG_ARRAY = new Array(65539),
+      BIG_ARRAY_2 = new Array(65539);
+
+for (var i_big = 0; i_big < BIG_ARRAY.length; i_big++) {
+  BIG_ARRAY[i_big] = Math.floor(Math.random() * 256);
+  BIG_ARRAY_2[i_big] = Math.floor(Math.random() * 256);
+}
+
+const BIG_TYPED_ARRAY = new Uint8Array(BIG_ARRAY),
+      BIG_TYPED_ARRAY_2 = new Uint8Array(BIG_ARRAY_2);
+      
+const TCPSocket = new (CC("@mozilla.org/tcp-socket;1",
+                     "nsIDOMTCPSocket"))();
+
+const gInChild = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime)
+                  .processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT;
+
+Cu.import("resource://gre/modules/Services.jsm");
+
+/**
+ *
+ * Helper functions
+ *
+ */
+
+
+function makeSuccessCase(name) {
+  return function() {
+    do_print('got expected: ' + name);
+    run_next_test();
+  };
+}
+
+function makeJointSuccess(names) {
+  let funcs = {}, successCount = 0;
+  names.forEach(function(name) {
+    funcs[name] = function() {
+      do_print('got expected: ' + name);
+      if (++successCount === names.length)
+        run_next_test();
+    };
+  });
+  return funcs;
+}
+
+function makeFailureCase(name) {
+  return function() {
+    let argstr;
+    if (arguments.length) {
+      argstr = '(args: ' +
+        Array.map(arguments, function(x) { return x + ""; }).join(" ") + ')';
+    }
+    else {
+      argstr = '(no arguments)';
+    }
+    do_throw('got unexpected: ' + name + ' ' + argstr);
+  };
+}
+
+function makeExpectData(name, expectedData, fromEvent, callback) {
+  let dataBuffer = fromEvent ? null : [], done = false;
+  return function(receivedData) {
+    if (fromEvent) {
+      receivedData = receivedData.data;
+      if (dataBuffer) {
+        let newBuffer = new Uint8Array(dataBuffer.length + receivedData.length);
+        newBuffer.set(dataBuffer, 0);
+        newBuffer.set(receivedData, dataBuffer.length);
+        dataBuffer = newBuffer;
+      }
+      else {
+        dataBuffer = receivedData;
+      }
+    }
+    else {
+      dataBuffer = dataBuffer.concat(receivedData);
+    }
+    do_print(name + ' received ' + receivedData.length + ' bytes');
+
+    if (done)
+      do_throw(name + ' Received data event when already done!');
+
+    if (dataBuffer.length >= expectedData.length) {
+      // check the bytes are equivalent
+      for (let i = 0; i < expectedData.length; i++) {
+        if (dataBuffer[i] !== expectedData[i]) {
+          do_throw(name + ' Received mismatched character at position ' + i);
+        }
+      }
+      if (dataBuffer.length > expectedData.length)
+        do_throw(name + ' Received ' + dataBuffer.length + ' bytes but only expected ' +
+                 expectedData.length + ' bytes.');
+
+      done = true;
+      if (callback) {
+        callback();
+      } else {
+        run_next_test();
+      }
+    }
+  };
+}
+
+var server = null, sock = null, acceptsock = null, failure_drain = null;
+var sock_2 = null, acceptsock_2 = null;
+
+/**
+ *
+ * Test functions
+ *
+ */
+
+/**
+ * Connect the socket to the server. This test is added as the first
+ * test, and is also added after every test which results in the socket
+ * being closed.
+ */
+
+function connectSock() {
+  if (server) {
+    server.close();
+  }
+
+  var yayFuncs = makeJointSuccess(['serveropen', 'clientopen']);
+  var options = { binaryType: 'arraybuffer' };
+
+  server = TCPSocket.listen(PORT, options, BACKLOG);
+  server.onaccept = function(socket) {
+    acceptsock = socket;
+    acceptsock.ondata = makeFailureCase('serverdata');
+    acceptsock.onclose = makeFailureCase('serverclose');
+    yayFuncs.serveropen();
+  };
+
+  sock = TCPSocket.open(
+    '127.0.0.1', PORT, options);
+
+  sock.onopen = yayFuncs.clientopen;
+  sock.ondrain = null;
+  sock.ondata = makeFailureCase('data');
+  sock.onerror = makeFailureCase('error');
+  sock.onclose = makeFailureCase('close');
+}
+
+/**
+ * Test that sending a small amount of data works, and that buffering
+ * does not take place for this small amount of data.
+ */
+
+function sendData() {
+  acceptsock.ondata = makeExpectData('serverdata', DATA_ARRAY, true);
+  if (!sock.send(TYPED_DATA_ARRAY)) {
+    do_throw("send should not have buffered such a small amount of data");
+  }
+}
+
+/**
+ * Test that sending a large amount of data works, that buffering
+ * takes place (send returns true), and that ondrain is called once
+ * the data has been sent.
+ */
+
+function sendBig() {
+  var yays = makeJointSuccess(['serverdata', 'clientdrain']),
+      amount = 0;
+      
+  acceptsock.ondata = function (receivedData) {
+    data = receivedData.data;
+    amount += data.length;
+    if (amount === BIG_TYPED_ARRAY.length) {
+      yays.serverdata();      
+    }
+  };
+  sock.ondrain = function(evt) {
+    if (sock.bufferedAmount) {
+      do_throw("sock.bufferedAmount was > 0 in ondrain");
+    }
+    yays.clientdrain(evt);
+  }
+  if (sock.send(BIG_TYPED_ARRAY)) {
+    do_throw("expected sock.send to return false on large buffer send");
+  }
+}
+
+/**
+ * Test that data sent from the server correctly fires the ondata
+ * callback on the client side.
+ */
+
+function receiveData() {
+  acceptsock.ondata = makeFailureCase('serverdata');
+  sock.ondata = makeExpectData('data', TYPED_DATA_ARRAY, true);
+
+  acceptsock.send(TYPED_DATA_ARRAY);
+}
+
+/**
+ * Test that when the server closes the connection, the onclose callback
+ * is fired on the client side.
+ */
+
+function serverCloses() {
+  // we don't really care about the server's close event, but we do want to
+  // make sure it happened for sequencing purposes.
+  var yayFuncs = makeJointSuccess(['clientclose', 'serverclose']);
+  sock.ondata = makeFailureCase('data');
+  sock.onclose = yayFuncs.clientclose;
+  acceptsock.onclose = yayFuncs.serverclose;
+
+  server.close();
+}
+
+/**
+ * Test that when the client closes the connection, the onclose callback
+ * is fired on the server side.
+ */
+
+function clientCloses() {
+  // we want to make sure the server heard the close and also that the client's
+  // onclose event fired for consistency.
+  var yayFuncs = makeJointSuccess(['clientclose', 'serverclose']);
+  acceptsock.onclose = yayFuncs.serverclose;
+  sock.onclose = yayFuncs.clientclose;
+
+  sock.close();
+}
+
+/**
+ * Send a large amount of data and immediately call close
+ */
+
+function bufferedClose() {
+  var yays = makeJointSuccess(['serverdata', 'clientclose', 'serverclose']);
+  acceptsock.ondata = makeExpectData(
+    "ondata", BIG_TYPED_ARRAY, false, yays.serverdata);
+  acceptsock.onclose = yays.serverclose;
+  sock.onclose = yays.clientclose;
+  sock.send(BIG_TYPED_ARRAY);
+  sock.close();
+}
+
+/**
+ * Connect to a port we know is not listening so an error is assured,
+ * and make sure that onerror and onclose are fired on the client side.
+ */
+ 
+function badConnect() {
+  // There's probably nothing listening on tcp port 2.
+  sock = TCPSocket.open('127.0.0.1', 2);
+
+  sock.onopen = makeFailureCase('open');
+  sock.ondata = makeFailureCase('data');
+  sock.onclose = makeFailureCase('close');
+
+  let success = makeSuccessCase('error');
+  sock.onerror = function(data) {
+    do_check_neq(data.data.message, '');
+    do_check_neq(data.data.fileName, '');
+    do_check_neq(data.data.lineNumber, 0);
+    success();
+  };
+}
+
+/**
+ * Test that calling send with enough data to buffer causes ondrain to
+ * be invoked once the data has been sent, and then test that calling send
+ * and buffering again causes ondrain to be fired again.
+ */
+
+function drainTwice() {
+  let yays = makeJointSuccess(
+    ['ondrain', 'ondrain2',
+    'ondata', 'ondata2',
+    'serverclose', 'clientclose']);
+
+  function serverSideCallback() {
+    yays.ondata();
+    acceptsock.ondata = makeExpectData(
+      "ondata2", BIG_TYPED_ARRAY_2, false, yays.ondata2);
+
+    sock.ondrain = yays.ondrain2;
+
+    if (sock.send(BIG_TYPED_ARRAY_2)) {
+      do_throw("sock.send(BIG_TYPED_ARRAY_2) did not return false to indicate buffering");
+    }
+
+    sock.close();
+  }
+
+  acceptsock.onclose = yays.serverclose;
+  acceptsock.ondata = makeExpectData(
+    "ondata", BIG_TYPED_ARRAY, true, serverSideCallback);
+
+  sock.onclose = yays.clientclose;
+  sock.ondrain = yays.ondrain;
+
+  if (sock.send(BIG_TYPED_ARRAY)) {
+    throw new Error("sock.send(BIG_TYPED_ARRAY) did not return false to indicate buffering");
+  }
+}
+
+function cleanup() {
+  do_print("Cleaning up");
+  sock.close();
+  sock_2.close();
+  server.close();
+  server = null;
+  
+  if (!gInChild)
+    Services.prefs.clearUserPref('dom.mozTCPSocket.enabled');
+  run_next_test();
+}
+
+/**
+ * Test that calling send with enough data to buffer twice in a row without
+ * waiting for ondrain still results in ondrain being invoked at least once.
+ */
+
+function bufferTwice() {
+  let yays = makeJointSuccess(
+    ['ondata', 'ondrain', 'serverclose', 'clientclose']);
+
+  let double_array = new Uint8Array(BIG_ARRAY.concat(BIG_ARRAY_2));
+  acceptsock.ondata = makeExpectData(
+    "ondata", double_array, false, yays.ondata);
+
+  acceptsock.onclose = yays.serverclose;
+  sock.onclose = yays.clientclose;
+
+  sock.ondrain = function () {
+    sock.close();
+    yays.ondrain();
+  }
+
+  if (sock.send(BIG_TYPED_ARRAY)) {
+    throw new Error("sock.send(BIG_TYPED_ARRAY) did not return false to indicate buffering");
+  }
+  if (sock.send(BIG_TYPED_ARRAY_2)) {
+    throw new Error("sock.send(BIG_TYPED_ARRAY_2) did not return false to indicate buffering on second synchronous call to send");
+  }
+}
+
+/**
+ * Connect client side sockets to the server twice.
+ */
+
+function connectSockTwice() {
+  if (server) {
+    server.close();
+  }
+
+  var yayFuncs = makeJointSuccess(['serveropen1', 'serveropen2', 'clientopen1', 'clientopen2']);
+  var options = { binaryType: 'arraybuffer' };
+  var connect_count = 0;
+
+  server = TCPSocket.listen(PORT, options, BACKLOG);
+  server.onaccept = function(socket) {
+    connect_count += 1;
+
+    if (connect_count == 1) {
+      acceptsock = socket;
+      acceptsock.ondata = makeFailureCase('serverdata1');
+      acceptsock.onclose = makeFailureCase('serverclose1');
+    }
+    else {
+      acceptsock_2 = socket;
+      acceptsock_2.ondata = makeFailureCase('serverdata2');
+      acceptsock_2.onclose = makeFailureCase('serverclose2');
+    }
+    yayFuncs['serveropen' + connect_count]();
+  };
+
+  sock = TCPSocket.open(
+    '127.0.0.1', PORT, options);
+  sock_2 = TCPSocket.open(
+    '127.0.0.1', PORT, options);
+
+  sock.onopen = yayFuncs.clientopen1;
+  sock.ondrain = null;
+  sock.ondata = makeFailureCase('data');
+  sock.onerror = makeFailureCase('error');
+  sock.onclose = makeFailureCase('close');
+
+  sock_2.onopen = yayFuncs.clientopen2;
+  sock_2.ondrain = null;
+  sock_2.ondata = makeFailureCase('data');
+  sock_2.onerror = makeFailureCase('error');
+  sock_2.onclose = makeFailureCase('close');
+}
+
+/**
+ * Test that sending a small amount of data works (using two sockets),
+ * and that buffering does not take place for this small amount of data.
+ */
+
+function sendDataTwice() {
+  let yays = makeJointSuccess(['ondata1', 'ondata2']);
+
+  acceptsock.ondata = makeExpectData('serverdata', DATA_ARRAY, true, yays.ondata1);
+  acceptsock_2.ondata = makeExpectData('serverdata', DATA_ARRAY_2, true, yays.ondata2);
+
+  if (!sock.send(TYPED_DATA_ARRAY)) {
+    do_throw("send should not have buffered such a small amount of data");
+  }
+  if (!sock_2.send(TYPED_DATA_ARRAY_2)) {
+    do_throw("send should not have buffered such a small amount of data");
+  }
+}
+
+/**
+ * Test that two data sent from the server correctly fire the ondata
+ * callbacks on the client side.
+ */
+
+function receiveDataTwice() {
+  let yays = makeJointSuccess(['ondata1', 'ondata2']);
+
+  acceptsock.ondata = makeFailureCase('serverdata1');
+  acceptsock_2.ondata = makeFailureCase('serverdata2');
+  sock.ondata = makeExpectData('data', TYPED_DATA_ARRAY, true, yays.ondata1);
+  sock_2.ondata = makeExpectData('data', TYPED_DATA_ARRAY_2, true, yays.ondata2);
+
+  acceptsock.send(TYPED_DATA_ARRAY);
+  acceptsock_2.send(TYPED_DATA_ARRAY_2);
+}
+
+/**
+ * Test that when the server closes the connection, the onclose callback
+ * is fired on the client side twice.
+ */
+
+function serverClosesTwice() {
+  // we don't really care about the server's close event, but we do want to
+  // make sure it happened for sequencing purposes.
+  var yayFuncs = makeJointSuccess(['clientclose1', 'serverclose1', 'clientclose2', 'serverclose2']);
+  sock.ondata = makeFailureCase('data');
+  sock.onclose = yayFuncs.clientclose1;
+  sock_2.ondata = makeFailureCase('data');
+  sock_2.onclose = yayFuncs.clientclose2;
+  acceptsock.onclose = yayFuncs.serverclose1;
+  acceptsock_2.onclose = yayFuncs.serverclose2;
+
+  server.close();
+}
+
+/**
+ * Test that when the client closes the connection, the onclose callback
+ * is fired on the server side twice.
+ */
+
+function clientClosesTwice() {
+  // we want to make sure the server heard the close and also that the client's
+  // onclose event fired for consistency.
+  var yayFuncs = makeJointSuccess(['clientclose1', 'serverclose1', 'clientclose2', 'serverclose2']);
+  sock.onclose = yayFuncs.clientclose1;
+  sock_2.onclose = yayFuncs.clientclose2;
+  acceptsock.onclose = yayFuncs.serverclose1;
+  acceptsock_2.onclose = yayFuncs.serverclose2;
+
+  sock.close();
+  sock_2.close();
+}
+
+// - connect, data and events work both ways
+add_test(connectSock);
+add_test(sendData);
+add_test(sendBig);
+add_test(receiveData);
+// - server closes on us
+add_test(serverCloses);
+
+// - connect, we close on the server
+add_test(connectSock);
+add_test(clientCloses);
+
+// - connect, buffer, close
+add_test(connectSock);
+add_test(bufferedClose);
+
+// - get an error on an attempt to connect to a non-listening port
+add_test(badConnect);
+
+// send a buffer, get a drain, send a buffer, get a drain
+add_test(connectSock);
+add_test(drainTwice);
+
+// send a buffer, get a drain, send a buffer, get a drain
+add_test(connectSock);
+add_test(bufferTwice);
+
+// - connect two sockets, data and events work both ways
+add_test(connectSockTwice);
+add_test(sendDataTwice);
+add_test(receiveDataTwice);
+// - server closes on us
+add_test(serverClosesTwice);
+
+// - connect, we close on the server
+add_test(connectSockTwice);
+add_test(clientClosesTwice);
+
+// clean up
+add_test(cleanup);
+
+function run_test() {
+  if (!gInChild)
+    Services.prefs.setBoolPref('dom.mozTCPSocket.enabled', true);
+
+  run_next_test();
+
+  do_timeout(10000, function() {
+    if (server) {
+      server.close();
+    }
+
+    do_throw(
+      "The test should never take this long unless the system is hosed.");
+  });
+}
diff --git a/dom/network/tests/unit/xpcshell.ini b/dom/network/tests/unit/xpcshell.ini
index a2b586d..a823f58 100644
--- a/dom/network/tests/unit/xpcshell.ini
+++ b/dom/network/tests/unit/xpcshell.ini
@@ -1,5 +1,6 @@
 [DEFAULT]
 head =
 tail =
 
 [test_tcpsocket.js]
+[test_tcpserversocket.js]
diff --git a/dom/network/tests/unit_ipc/test_tcpsocket_ipc.js b/dom/network/tests/unit_ipc/test_tcpsocket_ipc.js
index 9f876e0..b976e3d 100644
--- a/dom/network/tests/unit_ipc/test_tcpsocket_ipc.js
+++ b/dom/network/tests/unit_ipc/test_tcpsocket_ipc.js
@@ -1,9 +1,13 @@
 Components.utils.import("resource://gre/modules/Services.jsm");
 
 function run_test() {
   Services.prefs.setBoolPref('dom.mozTCPSocket.enabled', true);
   run_test_in_child("../unit/test_tcpsocket.js", function() {
     Services.prefs.clearUserPref('dom.mozTCPSocket.enabled');
     do_test_finished();
   });
-}
\ No newline at end of file
+  run_test_in_child("../unit/test_tcpserversocket.js", function() {
+    Services.prefs.clearUserPref('dom.mozTCPSocket.enabled');
+    do_test_finished();
+  });
+}
diff --git a/layout/build/nsLayoutModule.cpp b/layout/build/nsLayoutModule.cpp
index 6b1cbd4..10e639d 100644
--- a/layout/build/nsLayoutModule.cpp
+++ b/layout/build/nsLayoutModule.cpp
@@ -91,16 +91,17 @@
 #include "nsDOMStorage.h"
 #include "nsJSON.h"
 #include "mozilla/dom/indexedDB/IndexedDatabaseManager.h"
 #include "mozIApplicationClearPrivateDataParams.h"
 #include "mozilla/dom/DOMRequest.h"
 #include "mozilla/OSFileConstants.h"
 #include "mozilla/dom/Activity.h"
 #include "mozilla/dom/network/TCPSocketChild.h"
+#include "mozilla/dom/network/TCPServerSocketChild.h"
 
 #ifdef MOZ_B2G_RIL
 #include "SystemWorkerManager.h"
 using mozilla::dom::gonk::SystemWorkerManager;
 #define SYSTEMWORKERMANAGER_CID \
   {0xd53b6524, 0x6ac3, 0x42b0, {0xae, 0xca, 0x62, 0xb3, 0xc4, 0xe5, 0x2b, 0x04}}
 #define SYSTEMWORKERMANAGER_CONTRACTID \
   "@mozilla.org/telephony/system-worker-manager;1"
@@ -245,16 +246,17 @@ static void Shutdown();
 using namespace mozilla;
 using namespace mozilla::dom;
 using namespace mozilla::dom::file;
 using namespace mozilla::dom::sms;
 using mozilla::dom::alarm::AlarmHalService;
 using mozilla::dom::indexedDB::IndexedDatabaseManager;
 using mozilla::dom::power::PowerManagerService;
 using mozilla::dom::TCPSocketChild;
+using mozilla::dom::TCPServerSocketChild;
 using mozilla::dom::time::TimeService;
 
 // Transformiix
 /* 5d5d92cd-6bf8-11d9-bf4a-000a95dc234c */
 #define TRANSFORMIIX_NODESET_CID \
 { 0x5d5d92cd, 0x6bf8, 0x11d9, { 0xbf, 0x4a, 0x0, 0x0a, 0x95, 0xdc, 0x23, 0x4c } }
 
 #define TRANSFORMIIX_NODESET_CONTRACTID \
@@ -657,16 +659,17 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(nsPrincipal)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsSecurityNameSet)
 NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsSystemPrincipal,
     nsScriptSecurityManager::SystemPrincipalSingletonConstructor)
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsNullPrincipal, Init)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsStructuredCloneContainer)
 
 NS_GENERIC_FACTORY_CONSTRUCTOR(OSFileConstantsService)
 NS_GENERIC_FACTORY_CONSTRUCTOR(TCPSocketChild)
+NS_GENERIC_FACTORY_CONSTRUCTOR(TCPServerSocketChild)
 
 static nsresult
 Construct_nsIScriptSecurityManager(nsISupports *aOuter, REFNSIID aIID, 
                                    void **aResult)
 {
     if (!aResult)
         return NS_ERROR_NULL_POINTER;
     *aResult = nullptr;
@@ -820,16 +823,17 @@ NS_DEFINE_NAMED_CID(NS_HAPTICFEEDBACK_CID);
 #endif
 #endif
 NS_DEFINE_NAMED_CID(SMS_SERVICE_CID);
 NS_DEFINE_NAMED_CID(SMS_DATABASE_SERVICE_CID);
 NS_DEFINE_NAMED_CID(NS_POWERMANAGERSERVICE_CID);
 NS_DEFINE_NAMED_CID(OSFILECONSTANTSSERVICE_CID);
 NS_DEFINE_NAMED_CID(NS_ALARMHALSERVICE_CID);
 NS_DEFINE_NAMED_CID(TCPSOCKETCHILD_CID);
+NS_DEFINE_NAMED_CID(TCPSERVERSOCKETCHILD_CID);
 NS_DEFINE_NAMED_CID(NS_TIMESERVICE_CID);
 #ifdef MOZ_WIDGET_GONK
 NS_DEFINE_NAMED_CID(GONK_GPS_GEOLOCATION_PROVIDER_CID);
 #endif
 
 static nsresult
 CreateWindowCommandTableConstructor(nsISupports *aOuter,
                                     REFNSIID aIID, void **aResult)
@@ -1098,16 +1102,17 @@ static const mozilla::Module::CIDEntry kLayoutCIDs[] = {
   { &kNS_STRUCTUREDCLONECONTAINER_CID, false, NULL, nsStructuredCloneContainerConstructor },
   { &kNS_DOMMUTATIONOBSERVER_CID, false, NULL, nsDOMMutationObserverConstructor },
   { &kSMS_SERVICE_CID, false, NULL, nsISmsServiceConstructor },
   { &kSMS_DATABASE_SERVICE_CID, false, NULL, nsISmsDatabaseServiceConstructor },
   { &kNS_POWERMANAGERSERVICE_CID, false, NULL, nsIPowerManagerServiceConstructor },
   { &kOSFILECONSTANTSSERVICE_CID, true, NULL, OSFileConstantsServiceConstructor },
   { &kNS_ALARMHALSERVICE_CID, false, NULL, nsIAlarmHalServiceConstructor },
   { &kTCPSOCKETCHILD_CID, false, NULL, TCPSocketChildConstructor },
+  { &kTCPSERVERSOCKETCHILD_CID, false, NULL, TCPServerSocketChildConstructor },
   { &kNS_TIMESERVICE_CID, false, NULL, nsITimeServiceConstructor },
 #ifdef MOZ_WIDGET_GONK
   { &kGONK_GPS_GEOLOCATION_PROVIDER_CID, false, NULL, nsIGeolocationProviderConstructor },
 #endif
   { NULL }
 };
 
 static const mozilla::Module::ContractIDEntry kLayoutContracts[] = {
@@ -1240,16 +1245,17 @@ static const mozilla::Module::ContractIDEntry kLayoutContracts[] = {
   { NS_STRUCTUREDCLONECONTAINER_CONTRACTID, &kNS_STRUCTUREDCLONECONTAINER_CID },
   { NS_DOMMUTATIONOBSERVER_CONTRACTID, &kNS_DOMMUTATIONOBSERVER_CID },
   { SMS_SERVICE_CONTRACTID, &kSMS_SERVICE_CID },
   { SMS_DATABASE_SERVICE_CONTRACTID, &kSMS_DATABASE_SERVICE_CID },
   { POWERMANAGERSERVICE_CONTRACTID, &kNS_POWERMANAGERSERVICE_CID },
   { OSFILECONSTANTSSERVICE_CONTRACTID, &kOSFILECONSTANTSSERVICE_CID },
   { ALARMHALSERVICE_CONTRACTID, &kNS_ALARMHALSERVICE_CID },
   { "@mozilla.org/tcp-socket-child;1", &kTCPSOCKETCHILD_CID },
+  { "@mozilla.org/tcp-server-socket-child;1", &kTCPSERVERSOCKETCHILD_CID },
   { TIMESERVICE_CONTRACTID, &kNS_TIMESERVICE_CID },
 #ifdef MOZ_WIDGET_GONK
   { GONK_GPS_GEOLOCATION_PROVIDER_CONTRACTID, &kGONK_GPS_GEOLOCATION_PROVIDER_CID },
 #endif
   { NULL }
 };
 
 static const mozilla::Module::CategoryEntry kLayoutCategories[] = {
diff --git a/netwerk/ipc/NeckoChild.cpp b/netwerk/ipc/NeckoChild.cpp
index d472429..38d278c 100644
--- a/netwerk/ipc/NeckoChild.cpp
+++ b/netwerk/ipc/NeckoChild.cpp
@@ -9,18 +9,20 @@
 #include "mozilla/net/NeckoChild.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/net/HttpChannelChild.h"
 #include "mozilla/net/CookieServiceChild.h"
 #include "mozilla/net/WyciwygChannelChild.h"
 #include "mozilla/net/FTPChannelChild.h"
 #include "mozilla/net/WebSocketChannelChild.h"
 #include "mozilla/dom/network/TCPSocketChild.h"
+#include "mozilla/dom/network/TCPServerSocketChild.h"
 
 using mozilla::dom::TCPSocketChild;
+using mozilla::dom::TCPServerSocketChild;
 
 namespace mozilla {
 namespace net {
 
 PNeckoChild *gNeckoChild = nullptr;
 
 // C++ file contents
 NeckoChild::NeckoChild()
@@ -162,10 +164,27 @@ NeckoChild::AllocPTCPSocket(const nsString& aHost,
 bool
 NeckoChild::DeallocPTCPSocket(PTCPSocketChild* child)
 {
   TCPSocketChild* p = static_cast<TCPSocketChild*>(child);
   p->ReleaseIPDLReference();
   return true;
 }
 
+PTCPServerSocketChild*
+NeckoChild::AllocPTCPServerSocket(const uint16_t& aPort,
+                            const uint16_t& aBacklog,
+                            const nsString& aBinaryType)
+{
+  NS_NOTREACHED("AllocPTCPServerSocket should not be called");
+  return nullptr;
+}
+
+bool
+NeckoChild::DeallocPTCPServerSocket(PTCPServerSocketChild* child)
+{
+  TCPServerSocketChild* p = static_cast<TCPServerSocketChild*>(child);
+  p->ReleaseIPDLReference();
+  return true;
+}
+
 }} // mozilla::net
 
diff --git a/netwerk/ipc/NeckoChild.h b/netwerk/ipc/NeckoChild.h
index 8006c4c..b02d7f2 100644
--- a/netwerk/ipc/NeckoChild.h
+++ b/netwerk/ipc/NeckoChild.h
@@ -38,16 +38,20 @@ protected:
   virtual PWebSocketChild* AllocPWebSocket(PBrowserChild*);
   virtual bool DeallocPWebSocket(PWebSocketChild*);
   virtual PTCPSocketChild* AllocPTCPSocket(const nsString& aHost,
                                            const uint16_t& aPort,
                                            const bool& useSSL,
                                            const nsString& aBinaryType,
                                            PBrowserChild* aBrowser);
   virtual bool DeallocPTCPSocket(PTCPSocketChild*);
+  virtual PTCPServerSocketChild* AllocPTCPServerSocket(const uint16_t& aPort,
+                                           const uint16_t& aBacklog,
+                                           const nsString& aBinaryType);
+  virtual bool DeallocPTCPServerSocket(PTCPServerSocketChild*);
 };
 
 /**
  * Reference to the PNecko Child protocol.
  * Null if this is not a content process.
  */
 extern PNeckoChild *gNeckoChild;
 
diff --git a/netwerk/ipc/NeckoParent.cpp b/netwerk/ipc/NeckoParent.cpp
index ae43859..dcc51a0 100644
--- a/netwerk/ipc/NeckoParent.cpp
+++ b/netwerk/ipc/NeckoParent.cpp
@@ -9,22 +9,25 @@
 #include "mozilla/net/NeckoParent.h"
 #include "mozilla/net/HttpChannelParent.h"
 #include "mozilla/net/CookieServiceParent.h"
 #include "mozilla/net/WyciwygChannelParent.h"
 #include "mozilla/net/FTPChannelParent.h"
 #include "mozilla/net/WebSocketChannelParent.h"
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/dom/network/TCPSocketParent.h"
+#include "mozilla/dom/network/TCPServerSocketParent.h"
 
 #include "nsHTMLDNSPrefetch.h"
 
 using mozilla::dom::TabParent;
 using mozilla::net::PTCPSocketParent;
 using mozilla::dom::TCPSocketParent;
+using mozilla::net::PTCPServerSocketParent;
+using mozilla::dom::TCPServerSocketParent;
 
 namespace mozilla {
 namespace net {
 
 // C++ file contents
 NeckoParent::NeckoParent()
 {
 }
@@ -139,16 +142,44 @@ NeckoParent::RecvPTCPSocketConstructor(PTCPSocketParent* aActor,
 bool
 NeckoParent::DeallocPTCPSocket(PTCPSocketParent* actor)
 {
   TCPSocketParent* p = static_cast<TCPSocketParent*>(actor);
   p->Release();
   return true;
 }
 
+PTCPServerSocketParent*
+NeckoParent::AllocPTCPServerSocket(const uint16_t& aPort,
+                             const uint16_t& aBacklog,
+                             const nsString& aBinaryType)
+{
+  TCPServerSocketParent* p = new TCPServerSocketParent();
+  p->AddRef();
+  return p;
+}
+
+bool
+NeckoParent::RecvPTCPServerSocketConstructor(PTCPServerSocketParent* aActor,
+                                       const uint16_t& aPort,
+                                       const uint16_t& aBacklog,
+                                       const nsString& aBinaryType)
+{
+  return static_cast<TCPServerSocketParent*>(aActor)->
+      Init(aPort, aBacklog, aBinaryType);
+}
+
+bool
+NeckoParent::DeallocPTCPServerSocket(PTCPServerSocketParent* actor)
+{
+  TCPServerSocketParent* p = static_cast<TCPServerSocketParent*>(actor);
+  p->Release();
+  return true;
+}
+
 bool
 NeckoParent::RecvHTMLDNSPrefetch(const nsString& hostname,
                                  const uint16_t& flags)
 {
   nsHTMLDNSPrefetch::Prefetch(hostname, flags);
   return true;
 }
 
diff --git a/netwerk/ipc/NeckoParent.h b/netwerk/ipc/NeckoParent.h
index 1112e10..bd540f6 100644
--- a/netwerk/ipc/NeckoParent.h
+++ b/netwerk/ipc/NeckoParent.h
@@ -41,16 +41,24 @@ protected:
                                             PBrowserParent* aBrowser);
   virtual bool RecvPTCPSocketConstructor(PTCPSocketParent*,
                                          const nsString& aHost,
                                          const uint16_t& aPort,
                                          const bool& useSSL,
                                          const nsString& aBinaryType,
                                          PBrowserParent* aBrowser);
   virtual bool DeallocPTCPSocket(PTCPSocketParent*);
+  virtual PTCPServerSocketParent* AllocPTCPServerSocket(const uint16_t& aPort,
+                                            const uint16_t& aBacklog,
+                                            const nsString& aBinaryType);
+  virtual bool RecvPTCPServerSocketConstructor(PTCPServerSocketParent*,
+                                         const uint16_t& aPort,
+                                         const uint16_t& aBacklog,
+                                         const nsString& aBinaryType);
+  virtual bool DeallocPTCPServerSocket(PTCPServerSocketParent*);
   virtual bool RecvHTMLDNSPrefetch(const nsString& hostname,
                                    const uint16_t& flags);
   virtual bool RecvCancelHTMLDNSPrefetch(const nsString& hostname,
                                          const uint16_t& flags,
                                          const nsresult& reason);
 
 };
 
diff --git a/netwerk/ipc/PNecko.ipdl b/netwerk/ipc/PNecko.ipdl
index 9330fb0..0480727 100644
--- a/netwerk/ipc/PNecko.ipdl
+++ b/netwerk/ipc/PNecko.ipdl
@@ -8,16 +8,17 @@
 include protocol PContent;
 include protocol PHttpChannel;
 include protocol PCookieService;
 include protocol PBrowser;
 include protocol PWyciwygChannel;
 include protocol PFTPChannel;
 include protocol PWebSocket;
 include protocol PTCPSocket;
+include protocol PTCPServerSocket;
 
 include "SerializedLoadContext.h";
 
 using IPC::SerializedLoadContext;
 
 namespace mozilla {
 namespace net {
 
@@ -27,28 +28,30 @@ sync protocol PNecko
 {
   manager PContent;
   manages PHttpChannel;
   manages PCookieService;
   manages PWyciwygChannel;
   manages PFTPChannel;
   manages PWebSocket;
   manages PTCPSocket;
+  manages PTCPServerSocket;
 
 parent:
   __delete__();
 
   PCookieService();
   PHttpChannel(nullable PBrowser browser,
                SerializedLoadContext loadContext);
   PWyciwygChannel();
   PFTPChannel();
   PWebSocket(PBrowser browser);
   PTCPSocket(nsString host, uint16_t port, bool useSSL, nsString binaryType,
              nullable PBrowser browser);
+  PTCPServerSocket(uint16_t port, uint16_t backlog, nsString binaryType);
 
   HTMLDNSPrefetch(nsString hostname, uint16_t flags);
   CancelHTMLDNSPrefetch(nsString hostname, uint16_t flags, nsresult reason);
 
 };
 
 
 } // namespace net
